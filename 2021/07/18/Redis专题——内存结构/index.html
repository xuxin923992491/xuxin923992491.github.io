<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis专题——内存结构 | 努力努力再努力</title><meta name="author" content="xuxin923992491"><meta name="copyright" content="xuxin923992491"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis的三个重要特点特点1：丰富的数据类型对比其他数据库我们知道很多数据库只能处理一种数据结构：  传统SQL数据库处理二维关系数据； MemCached数据库，键和值都是字符串； 文档数据库（MongoDB）是由Json&#x2F;Bson组成的文档。  当然不是他们这些数据库不好，而是一旦数据库提供数据结构不适合去做某件事情的话，程序写起来就非常麻烦和不自然。 Redis的丰富 Redis虽然也是键">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis专题——内存结构">
<meta property="og:url" content="https://xuxin923992491.github.io/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="努力努力再努力">
<meta property="og:description" content="Redis的三个重要特点特点1：丰富的数据类型对比其他数据库我们知道很多数据库只能处理一种数据结构：  传统SQL数据库处理二维关系数据； MemCached数据库，键和值都是字符串； 文档数据库（MongoDB）是由Json&#x2F;Bson组成的文档。  当然不是他们这些数据库不好，而是一旦数据库提供数据结构不适合去做某件事情的话，程序写起来就非常麻烦和不自然。 Redis的丰富 Redis虽然也是键">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2021-07-18T01:38:46.793Z">
<meta property="article:modified_time" content="2021-07-17T08:49:57.736Z">
<meta property="article:author" content="xuxin923992491">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xuxin923992491.github.io/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-17 16:49:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">努力努力再努力</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis专题——内存结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-18T01:38:46.793Z" title="Created 2021-07-18 09:38:46">2021-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-07-17T08:49:57.736Z" title="Updated 2021-07-17 16:49:57">2021-07-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis的三个重要特点"><a href="#Redis的三个重要特点" class="headerlink" title="Redis的三个重要特点"></a>Redis的三个重要特点</h1><h2 id="特点1：丰富的数据类型"><a href="#特点1：丰富的数据类型" class="headerlink" title="特点1：丰富的数据类型"></a>特点1：丰富的数据类型</h2><h3 id="对比其他数据库"><a href="#对比其他数据库" class="headerlink" title="对比其他数据库"></a>对比其他数据库</h3><p>我们知道很多数据库只能处理一种数据结构：</p>
<ul>
<li>传统SQL数据库处理二维关系数据；</li>
<li>MemCached数据库，键和值都是字符串；</li>
<li>文档数据库（MongoDB）是由Json/Bson组成的文档。</li>
</ul>
<p>当然不是他们这些数据库不好，而是一旦数据库提供数据结构不适合去做某件事情的话，程序写起来就非常麻烦和不自然。</p>
<h3 id="Redis的丰富"><a href="#Redis的丰富" class="headerlink" title="Redis的丰富"></a>Redis的丰富</h3><ul>
<li>Redis虽然也是键值对数据库，但是和Memcached不同的是：Redis值不仅可以是字符串，也可以是其他五种数据结构中任意一种。</li>
<li>通过选用不同的数据结构，用户可以使用Redis解决各种各样的问题，使用Redis，你碰到一个问题，首先会想到是选用那种数据结构把哪些功能问题解决掉，有了多样的数据结构，方便你解决问题。</li>
</ul>
<h2 id="特点2：内存存储"><a href="#特点2：内存存储" class="headerlink" title="特点2：内存存储"></a>特点2：内存存储</h2><p>数据库有两种：一种是硬盘数据库，一种是内存数据库。</p>
<h3 id="硬盘数据库"><a href="#硬盘数据库" class="headerlink" title="硬盘数据库"></a>硬盘数据库</h3><ul>
<li>硬盘数据库是把值存储在硬盘上，在内存中就存储一下索引，当硬盘数据库想访问硬盘的值时，它先在内存找到索引，然后再找值。</li>
<li>问题在于，在读取和写入硬盘的时候，如果读写比较多的时候，它会把硬盘的IO功能堵死。</li>
</ul>
<h3 id="内存数据库"><a href="#内存数据库" class="headerlink" title="内存数据库"></a>内存数据库</h3><ul>
<li>内存存储是将所有的数据都存储在内存里面，数据读取和写入速度非常快。</li>
</ul>
<h2 id="特点3：持久化功能"><a href="#特点3：持久化功能" class="headerlink" title="特点3：持久化功能"></a>特点3：持久化功能</h2><p>将数据存储在内存里面的数据保存到硬盘中，保证数据安全，方便进行数据备份和恢复。</p>
<h1 id="为什么使用Redis作为缓存"><a href="#为什么使用Redis作为缓存" class="headerlink" title="为什么使用Redis作为缓存"></a>为什么使用Redis作为缓存</h1><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>用户第一次访问数据慢是因为要从磁盘上读取，将用户访问的数据存入缓存中，再次访问就可以从缓存中获取，所以速度很快，但是如果数据库中对应的数据改变之后，需要同步改变缓存中相应的数据即可</p>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>直接操作缓存能够承受的请求远远大于直接访问数据库，所以考虑将部分数据转移到缓存中，这样获取一部分数据就不用经过数据库了</p>
<h1 id="为什么使用Redis而不用map-guava做缓存"><a href="#为什么使用Redis而不用map-guava做缓存" class="headerlink" title="为什么使用Redis而不用map/guava做缓存"></a>为什么使用Redis而不用map/guava做缓存</h1><ul>
<li>缓存分为本地缓存和分布式缓存</li>
<li>map或者guava实现的是本地缓存，特点是轻量级，快速，声明周期随着jvm的销毁而结束，多个实例下，每个实例都需要各自保存一份缓存，不具有一致性</li>
<li>redis或memcached之类的成为分布式缓存，多实例公用一份缓存数据，缓存具有一致性，缺点是需要保持redis或者memcached服务的高可用，整个程序架构上比较复杂</li>
</ul>
<h1 id="Redis和Memcached区别"><a href="#Redis和Memcached区别" class="headerlink" title="Redis和Memcached区别"></a>Redis和Memcached区别</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>redis支持更丰富的数据类型，不只是key-value类型，也提供list，set，zset，hash等数据结构的存储</li>
<li>后者仅支持简单的数据类型</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul>
<li>前者支持持久化，可将数据保存在磁盘中，重启的时候可以再次加载进行使用</li>
<li>后者仅保存在内存中</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><ul>
<li>Redis支持cluster模式</li>
<li>后者没有原生的集群模式</li>
</ul>
<h2 id="线程模型："><a href="#线程模型：" class="headerlink" title="线程模型："></a>线程模型：</h2><ul>
<li>前者是单线程的多路IO复用模型</li>
<li>后者是多线程，非阻塞IO复用的网络模型</li>
</ul>
<h1 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h1><p>Redis是key-value数据库，key的类型只能是String，但是value的数据类型就比较丰富了，主要包括五种：</p>
<h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>String类型是二进制安全的。意思是redis的String可以包含任何数据。比如jpg图片或者序列化的对象。</li>
<li>String类型是Redis最基本的数据类型，一个键最大能存储512MB。</li>
<li>通过type key能够知道key是什么数据类型</li>
</ul>
<h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>底层数据结构是简单动态字符串（SDS），根据字符串的类型和长度还会细分数据类型，通过object encoding key可以得知具体数据结构</p>
<ul>
<li>能转整数的是int类型，incr key可以对int类型的key的value自增1</li>
<li>小于等于44字节的是embstr类型</li>
<li>大于44字节的是raw类型</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>字符串类型的使用场景：信息缓存、计数器、分布式锁等等。</p>
</li>
<li><p>实战场景1：记录每一个用户的访问次数，或者记录每一个商品的浏览次数，或者某个帖子阅读数，方案如下：</p>
<ul>
<li>常用键名： userid:pageview 或者 pageview:userid，如果一个用户的id为123，那对应的redis key就为pageview:123，value就为用户的访问次数，增加次数可以使用命令：incr。</li>
<li>使用理由：每一个用户访问次数或者商品浏览次数的修改是很频繁的，如果使用mysql这种文件系统频繁修改会造成mysql压力，效率也低。而使用redis的好处有二：使用内存，很快；单线程，所以无竞争，数据不会被改乱。</li>
</ul>
</li>
<li><p>实战场景2：缓存频繁读取，但是不常修改的信息，如用户信息，视频信息，方案如下：</p>
<ul>
<li>业务逻辑上：先从redis读取，有值就从redis读取，没有则从mysql读取，并写一份到redis中作为缓存，注意要设置过期时间。</li>
<li>键值设计上：直接将用户一条mysql记录做序列化(通常序列化为json)作为值，userInfo:userid 作为key，键名如：userInfo:123，value存储对应用户信息的json串。如 key为：”userInfo :123”, value为”{“name”:”leijia”,”age”:18}”。</li>
</ul>
</li>
<li><p>实战场景3：限定某个ip特定时间内的访问次数，方案如下：</p>
<ul>
<li>用key记录IP，value记录访问次数，同时key的过期时间设置为60秒，如果key过期了则重新设置，否则进行判断，当一分钟内访问超过100次，则禁止访问。</li>
</ul>
</li>
<li><p>实战场景4：分布式系统全局序列号自增，方案如下：</p>
<ul>
<li>当数据库分库分表的时候，原来的自增主键方案会出现问题，因此需要设置全局id</li>
<li>此时可以通过redis来为数据库分配主键id</li>
<li>incrby指令能够批量生成序列号，提升性能</li>
</ul>
</li>
</ul>
<h2 id="Hash哈希"><a href="#Hash哈希" class="headerlink" title="Hash哈希"></a>Hash哈希</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Redis hash 是一个键值(key=&gt;value)对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<h3 id="底层-1"><a href="#底层-1" class="headerlink" title="底层"></a>底层</h3><ul>
<li>有的场景是哈希表，有的场景采用的是压缩列表（类似于单链表，中间取消了一些指针相连的内容）</li>
<li>只有同时满足下面两个条件时，才会使用压缩列表：哈希中元素数量小于512个；哈希中所有键值对的键和值字符串长度都小于64字节。如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>以购物车为例子，用户id设置为key，那么购物车里所有的商品就是用户key对应的值了，每个商品有id和购买数量，对应hash的结构就是商品id为field，商品数量为value。</li>
<li>即key：用户id，value：小米手机，1件；iphone12,1件，这里的小米手机和iphone叫做属性，件数叫做属性值，属性+属性值统称为为hash中的value</li>
<li>如果将商品id和商品数量序列化成json字符串，那么也可以用上面讲的string类型存储，即key为用户id，value为“{小米：1件，iphone12,1件}”</li>
<li>当对象的某个属性需要频繁修改时，不适合用string+json，因为它不够灵活，每次修改都需要重新将整个对象序列化并赋值；如果使用hash类型，则可以针对某个属性单独修改，没有序列化，也不需要修改整个对象。比如，商品的价格、销量、关注数、评价数等可能经常发生变化的属性，就适合存储在hash类型里。</li>
<li>在Redis中操作购物车直接使用redis的指令就可以了，不需要通过Java和数据库来编写逻辑，方便快捷<ul>
<li>添加商品：hset  用户id（作为key） 商品编号（作为属性）  1（属性值，表示购买了1个）</li>
<li>增加数量：hincrby    用户id（作为key） 商品编号（作为属性）  1（属性值，表示增加1个）</li>
<li>商品总数：hlen   用户id（作为key）</li>
<li>删除商品：hdel   用户id（作为key） 商品编号（作为属性）</li>
<li>获取购物车所有商品：hgetall  用户id（作为key）</li>
</ul>
</li>
</ul>
<h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。 可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<h3 id="底层-2"><a href="#底层-2" class="headerlink" title="底层"></a>底层</h3><ul>
<li>有的场景使用的是压缩列表，有的使用的是双向链表</li>
<li>当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。</li>
<li>只有同时满足下面两个条件时，才会使用压缩列表：列表中元素数量小于512个；列表中所有字符串对象都不足64字节。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。</li>
</ul>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>列表本质是一个有序的，元素可重复的队列。</p>
</li>
<li><p>实战场景：定时排行榜</p>
<ul>
<li>list类型的lrange命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如QQ音乐内地排行榜，每周计算一次存储在list类型中</li>
<li>但是，并不是所有的排行榜都能用list类型实现，只有定时计算的排行榜才适合使用list类型存储</li>
<li>与定时计算的排行榜相对应的是实时计算的排行榜，list类型不能支持实时计算的排行榜，下面介绍有序集合sorted set的应用场景时会详细介绍实时计算的排行榜的实现。</li>
</ul>
</li>
<li><p>实战场景：微信订阅号或者微博列表展示</p>
<ul>
<li>通常博主发的消息或者订阅号发布的新文章都是越新的内容或者刚创建的在列表最上面，那么如果说使用数据库来展示的话，还需要按照创建时间进行order by，消耗很大资源，更何况这些列表展示是非常频繁的操作，因此redis提供的list非常方便</li>
<li>比如说我关注了A和B这两个公众号或者微博</li>
<li>当A发微博或者更新文章了，此时会在我的所处服务器的Redis当中执行LPUSH   key（我的微信或微博id）  value（消息id）</li>
<li>当B再发的时候，也会执行同样的指令</li>
<li>此时我们在打开微信订阅号或者微博的时候，就会发现，我们关注的这些账户发的消息就已经按照先后顺序已经排好了，直接查看就可以了</li>
<li>如果想要查看最新的消息或最近的几条消息，可使用指令LRANGE   key（我的微信或微博id）  0（list起始下标）  选取的个数    </li>
</ul>
</li>
</ul>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>Redis的Set是string类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<h3 id="底层-3"><a href="#底层-3" class="headerlink" title="底层"></a>底层</h3><ul>
<li>有的采用的是哈希表，有的采用整数数组</li>
<li>只有同时满足下面两个条件时，集合才会使用整数集合：集合中元素数量小于512个；集合中所有元素都是整数值。如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。</li>
</ul>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>集合的特点是无序性和确定性（不重复）。</p>
</li>
<li><p>实战场景：收藏夹</p>
<ul>
<li>例如QQ音乐中如果你喜欢一首歌，点个『喜欢』就会将歌曲放到个人收藏夹中，每一个用户做一个收藏的集合，每个收藏的集合存放用户收藏过的歌曲id。</li>
<li>key为用户id，value为歌曲id的集合。</li>
</ul>
</li>
<li><p>实战场景：微信小程序抽奖</p>
<ul>
<li>点击参与抽奖此时就是将用户加入集合中，使用指令SADD key(活动编号)   value(用户id)</li>
<li>查看所有的抽奖用户，可以使用指令SMEMBERS  key(活动编号) </li>
<li>抽取count名中奖者，可以使用指令SRANDMEMBER  key(活动编号)  [count]</li>
<li>这种方式仅仅只是展示抽奖用户，但是不能够区分出几等奖，如果想要展示出几等奖，那么就把中奖的用户从集合中移除再次进行抽奖，此时就能够区分出几等奖，比如第一次移除的这些是三等奖，再抽的话是二等奖，使用的指令为SPOP   key(活动编号)   [count]</li>
</ul>
</li>
<li><p>实战场景：微信微博点赞，以朋友圈举例</p>
<ul>
<li>当点赞的时候，使用指令SADD   key(该条朋友圈的编号)    value(点赞人的id)</li>
<li>取消点赞的时候，使用指令SREM   key(该条朋友圈的编号)    value(点赞人的id)，即从该条消息的点赞集合中删除</li>
<li>获取点赞用户的列表，使用指令SMEMBERS    key(该条朋友圈的编号)</li>
<li>判断是否点过赞，使用指令SISMEMBER  key(该条朋友圈的编号)   value(点赞人的id)</li>
<li>获取点赞用户数，使用指令SCARD  key(该条朋友圈的编号)</li>
</ul>
</li>
<li><p>实战场景：实现微信微博关注模型（共同关注、我关注的人也关注他，可能认识的人等功能）</p>
<ul>
<li>关注模型的实现其实就是集合之间的操作</li>
<li>假设现在有几个集合，A，B，C三个人，关注的人对应三个集合，集合的内容是他们关注的人</li>
<li>现在如果想要知道A,B的共同关注的人，其实就是集合的交集，使用指令SINTER   A集合   B集合，此时就能返回交集</li>
<li>现在想要知道A关注的人是否关注过C，其实就是C是否在我关注的人的集合当中，如果是，就返回这个人，可以使用指令SISMEMBER   我关注的人的集合    C，此时就是需要多次对我关注的人执行这个指令，如果有，那么就返回这个人，那么如果我关注的人特别多，那么岂不是要执行多次？我们发现通常显示的只有4,5个左右，因此只需要找几个显示就行了，如果点查看更多，此时也就是一个分页操作</li>
<li>现在想要知道我可能认识的人，其实就是一个补集的运算过程，比如说A关注了B，D,E,F，B关注了A，D,E，那么A可能认识的人就是F，使用的指令为SDIFF  A集合   B集合，注意，这个只是一种粗略的可能认识的人的算法，还有更精准的，暂不讨论</li>
</ul>
</li>
</ul>
<h2 id="Sorted-Set有序集合"><a href="#Sorted-Set有序集合" class="headerlink" title="Sorted Set有序集合"></a>Sorted Set有序集合</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><ul>
<li>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。</li>
<li>redis正是通过分数来为集合中的成员进行从小到大的排序。</li>
<li>zset的成员是唯一的,但分数(score)却可以重复。</li>
</ul>
<h3 id="底层-4"><a href="#底层-4" class="headerlink" title="底层"></a>底层</h3><ul>
<li>有的使用的是压缩列表，有的使用的是跳表</li>
<li>可以使用object encoding  key查看一下底层使用的数据结构，ziplist就是压缩列表，也是默认的数据结构，skiplist是跳表</li>
<li>当元素个数超过128，将使用跳表或者单个元素的大小超过64byte，也会使用跳表（这两个值不是固定的，可以进行设置），redis自动优化转换底层结构</li>
<li>压缩列表具备链表的特点，插入便捷，查找复杂，因此跳表就是对链表的改进，使链表在查找的速度进行了优化</li>
<li>什么是跳表<ul>
<li>跳表最开始其实就是一个链表，查找效率不高，该链表是排好序的</li>
<li>为了提高查找效率，将链表从左向右每两个元素的第一个元素提取出来组成一个新的索引层链表，然后还会继续再向上构建索引层，直到不能再构建为止</li>
<li>构建索引层的作用是什么呢？因为都是排好序的，可以按照比较大小的方式一层一层向下去找，当数据量非常大的时候，此时查找效率非常高，其实查找的方式类似于B+数索引的形式，但是这里叫做跳表，注意，只是类似B+树，而不是，这里是链表的形</li>
<li>总结一下跳表，跳表将有序链表改造为支持“折半查找”算法，可以进行快速的插入、删除、查找操作，复杂度为O(logN)</li>
</ul>
</li>
</ul>
<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>有序集合的特点是有序，无重复值。与set不同的是sorted set每个元素都会关联一个score属性，redis正是通过score来为集合中的成员进行从小到大的排序。</p>
</li>
<li><p>实战场景：实时排行榜</p>
<ul>
<li>QQ音乐中有多种实时榜单，比如飙升榜、热歌榜、新歌榜</li>
<li>可以用redis key存储榜单类型，score为点击量，value为歌曲id，用户每点击一首歌曲会更新redis数据，sorted set会依据score即点击量将歌曲id排序。</li>
</ul>
</li>
<li><p>实战场景：微博实时排行榜</p>
<ul>
<li>当我们点击某个微博的时候，此时会创建集合，使用指令ZINCRBY  key(集合名字)   1(带有的分值)    value(热搜名字)，当再点这条新闻的时候，该新闻的分值就自动加1，此时完成了实时的功能</li>
<li>当然可以展示当日排行前十的新闻（其实就是热搜），那么就可以用指令ZREVRANGE   key(集合名字)    0   9(排序的下标)  WITHSCORES，此时完成了实时排行榜</li>
</ul>
</li>
</ul>
<h1 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h1><h2 id="什么是Redis的单线程模型"><a href="#什么是Redis的单线程模型" class="headerlink" title="什么是Redis的单线程模型"></a>什么是Redis的单线程模型</h2><p>Redis的单线程模型是指，在处理用户请求的过程中，使用了文件事件处理器的模型，这个模型是个单线程模型，具体包括：多个Socket，IO多路复用程序，文件事件分派器，事件处理器（含连接应答、命令请求、命令回复）</p>
<h2 id="单线程模型的好处"><a href="#单线程模型的好处" class="headerlink" title="单线程模型的好处"></a>单线程模型的好处</h2><p>没有线程切换带来的开销，基于内存的读写操作效率高。</p>
<h2 id="Redis单线程模型流程（NIO）"><a href="#Redis单线程模型流程（NIO）" class="headerlink" title="Redis单线程模型流程（NIO）"></a>Redis单线程模型流程（NIO）</h2><ul>
<li>采用IO多路复用机制，同时监听多个客户端的连接请求Socket，并且把所有产生事件的Socket压入一个队列中，由文件事件分派器有序地每次取出一个socket给对应的事件处理器进行处理（包括连接应答，请求命令，命令回复）</li>
<li>具体的流程就是NIO的整个操作过程，底层原理就是epoll方法的调用</li>
<li>通过redis的源码可以看到，C语言中的三个核心方法就是epoll_create,epoll_ctl,epoll_wait这三个方法，那么Redis的单线程模型的过程就是有这三个核心方法来实现的</li>
</ul>
<h1 id="Redis缓存淘汰机制"><a href="#Redis缓存淘汰机制" class="headerlink" title="Redis缓存淘汰机制"></a>Redis缓存淘汰机制</h1><h2 id="redis设置过期时间"><a href="#redis设置过期时间" class="headerlink" title="redis设置过期时间"></a>redis设置过期时间</h2><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>为了保证实时性，需要redis设置一个过期时间，防止一直占用缓存，可以给一个expire time，就是过期时间，指定key可以存活的时间，那么设置一批key只存活一个小时，那么接下来的一小时后，redis是怎么对这批key进行删除的？</p>
<h3 id="两种删除方式："><a href="#两种删除方式：" class="headerlink" title="两种删除方式："></a>两种删除方式：</h3><ul>
<li><p>定期删除：默认是每隔100s随机抽取设置了过期时间的key，检查是否过期，过期就删除掉，随机的原因是因为数据太多，全部遍历的话耗时耗性能</p>
</li>
<li><p>惰性删除：定期删除导致了很多到期的没有删除，那么就还停留在内存当中，那么就要去主动去查一下到期的key了</p>
</li>
<li><p>上述的两种删除仍然会导致内存中堆积大量过期key，导致redis会内存耗尽，那么就需要redis内存淘汰机制</p>
</li>
</ul>
<h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><h3 id="面向的问题"><a href="#面向的问题" class="headerlink" title="面向的问题"></a>面向的问题</h3><p>主要问题就是加入mysql有2000w数据，如何保证redis中的数据都是热点实时数据而不是长时间不用的旧数据</p>
<h3 id="六种淘汰策略"><a href="#六种淘汰策略" class="headerlink" title="六种淘汰策略"></a>六种淘汰策略</h3><ul>
<li>volatile-lru：从已设置过期时间的数据块挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集中任意选择淘汰</li>
<li>allkeys-lru：内存不足以容纳新写入数据时，在键空间中移除最少使用的key（最常用）</li>
<li>allkeys-random:从数据集中任意选择淘汰</li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">xuxin923992491</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xuxin923992491.github.io/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">https://xuxin923992491.github.io/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Redis专题——持久化</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/10/%E9%98%B6%E6%AE%B5%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%88Redis%E7%AF%87%EF%BC%89/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">阶段性复习（Redis篇）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">xuxin923992491</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">Redis的三个重要特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B91%EF%BC%9A%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">特点1：丰富的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.1.</span> <span class="toc-text">对比其他数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E4%B8%B0%E5%AF%8C"><span class="toc-number">1.1.2.</span> <span class="toc-text">Redis的丰富</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B92%EF%BC%9A%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.</span> <span class="toc-text">特点2：内存存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">硬盘数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">内存数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B93%EF%BC%9A%E6%8C%81%E4%B9%85%E5%8C%96%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.</span> <span class="toc-text">特点3：持久化功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">为什么使用Redis作为缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-number">2.1.</span> <span class="toc-text">高性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="toc-number">2.2.</span> <span class="toc-text">高并发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Redis%E8%80%8C%E4%B8%8D%E7%94%A8map-guava%E5%81%9A%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">为什么使用Redis而不用map&#x2F;guava做缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%92%8CMemcached%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">Redis和Memcached区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">4.3.</span> <span class="toc-text">集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-number">4.4.</span> <span class="toc-text">线程模型：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">Redis的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.</span> <span class="toc-text">String字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82"><span class="toc-number">5.1.2.</span> <span class="toc-text">底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.1.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E5%93%88%E5%B8%8C"><span class="toc-number">5.2.</span> <span class="toc-text">Hash哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">5.2.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E5%88%97%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">List列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">5.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82-2"><span class="toc-number">5.3.2.</span> <span class="toc-text">底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">5.3.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">5.4.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">5.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82-3"><span class="toc-number">5.4.2.</span> <span class="toc-text">底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">5.4.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorted-Set%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">5.5.</span> <span class="toc-text">Sorted Set有序集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-number">5.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82-4"><span class="toc-number">5.5.2.</span> <span class="toc-text">底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">5.5.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">Redis线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">什么是Redis的单线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">6.2.</span> <span class="toc-text">单线程模型的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%B5%81%E7%A8%8B%EF%BC%88NIO%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">Redis单线程模型流程（NIO）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">Redis缓存淘汰机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">7.1.</span> <span class="toc-text">redis设置过期时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="toc-number">7.1.1.</span> <span class="toc-text">目的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%88%A0%E9%99%A4%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">7.1.2.</span> <span class="toc-text">两种删除方式：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">内存淘汰机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.1.</span> <span class="toc-text">面向的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E7%A7%8D%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">7.2.2.</span> <span class="toc-text">六种淘汰策略</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E2%80%94%E2%80%94Redis%E5%92%8CZookeeper/" title="分布式锁——Redis和Zookeeper"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式锁——Redis和Zookeeper"/></a><div class="content"><a class="title" href="/2021/07/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E2%80%94%E2%80%94Redis%E5%92%8CZookeeper/" title="分布式锁——Redis和Zookeeper">分布式锁——Redis和Zookeeper</a><time datetime="2021-07-18T15:06:28.429Z" title="Created 2021-07-18 23:06:28">2021-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" title="Redis专题——安全问题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis专题——安全问题"/></a><div class="content"><a class="title" href="/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" title="Redis专题——安全问题">Redis专题——安全问题</a><time datetime="2021-07-18T13:53:55.525Z" title="Created 2021-07-18 21:53:55">2021-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96/" title="Redis专题——持久化"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis专题——持久化"/></a><div class="content"><a class="title" href="/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96/" title="Redis专题——持久化">Redis专题——持久化</a><time datetime="2021-07-18T01:38:46.795Z" title="Created 2021-07-18 09:38:46">2021-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" title="Redis专题——内存结构"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis专题——内存结构"/></a><div class="content"><a class="title" href="/2021/07/18/Redis%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" title="Redis专题——内存结构">Redis专题——内存结构</a><time datetime="2021-07-18T01:38:46.793Z" title="Created 2021-07-18 09:38:46">2021-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/10/%E9%98%B6%E6%AE%B5%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%88Redis%E7%AF%87%EF%BC%89/" title="阶段性复习（Redis篇）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阶段性复习（Redis篇）"/></a><div class="content"><a class="title" href="/2021/06/10/%E9%98%B6%E6%AE%B5%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%88Redis%E7%AF%87%EF%BC%89/" title="阶段性复习（Redis篇）">阶段性复习（Redis篇）</a><time datetime="2021-06-10T12:35:26.504Z" title="Created 2021-06-10 20:35:26">2021-06-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By xuxin923992491</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>